{"./":{"url":"./","title":"简介","keywords":"","body":"简介 Markdown 是一种轻量级标记语言，它用简洁的语法代替排版，使我们专心于码字。它的目标是实现易读易写，成为一种适用于网络的书写语言。同时，Markdown支持嵌入html标签。 Copyright © liujizhe.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-04-07 11:17:58 "},"Markdown/常用语法.html":{"url":"Markdown/常用语法.html","title":"常用语法","keywords":"","body":"常用语法 注意：Markdown使用#、+、*等符号来标记， 符号后面必须跟上 至少1个 空格才有效! 1. 标题 在标题开头加上1~6个#，依次代表一级标题、二级标题....六级标题 # 一级标题 ## 二级标题 ### 三级标题 ##### 四级标题 ###### 五级标题 ###### 六级标题 2. 列表 Markdown 支持有序列表和无序列表。 无序列表使用-、+和*作为列表标记： - Red - Green - Blue * Red * Green * Blue + Red + Green + Blue 有序列表则使用数字加英文句点.来表示： 1. Red 2. Green 3. Blue 3. 强调 两个或_代表加粗，一个或_代表斜体，~~代表删除。 **加粗文本** 或者 __加粗文本__ *斜体文本* 或者_斜体文本_ ~~删除文本~~ 4. 图片与链接 图片与链接的语法很像，区别在一个 ! 号。二者格式： 图片：![]() ![图片文本(可忽略)](图片地址) 链接：[]() [链接文本](链接地址) 链接又分为行内式、参考式和 自动链接： 这是行内式链接：[ConnorLin's Blog](http://connorlin.github.io)。 这是参考式链接：[ConnorLin's Blog][url]，其中url为链接标记，可置于文中任意位置。 [url]: http://connorlin.github.io/ \"ConnorLin's Blog\" 链接标记格式为 [链接标记文本]: 链接地址 链接title(可忽略) 这是自动链接：直接使用`<>`括起来 这是图片：![][avatar] [avatar]: https://connorlin.github.io/images/avatar.jpg 5. 代码框 代码分为行内代码和代码块 行内代码使用单反引号代码 标识，可嵌入文字中 缩进每一行由至少 4 个空格或 1 个制表符Tab。 6. 段落 每个段落从一个新行开始，段落前最好有一个空行。只需按下回车键开始一个新行。 7. 引用 引用以>来表示，引用中支持多级引用、标题、列表、代码块、分割线等常规语法。 常见的引用写法： > 这是一段引用 //在`>`后面有 1 个空格 > > 这是引用的代码块形式 //在`>`后面有 5 个空格 > > 代码例子： > protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } > 一级引用 >> 二级引用 >>> 三级引用 > #### 这是一个四级标题 > > 1. 这是第一行列表项 > 2. 这是第二行列表项 8. 分隔线 分割线可以由* - _（星号，减号，下划线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以。 9. 换行 在行尾添加两个空格加回车表示换行。 Copyright © liujizhe.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-04-07 11:50:34 "},"GitBook/":{"url":"GitBook/","title":"简介","keywords":"","body":"简介 Modern book format and toolchain using Git and Markdown 这是 gitbook 项目主页上对 gitbook 的定义。 gitbook 首先是一个软件，正如上面定义的那样，它使用 Git 和 Markdown 来编排书本，如果用户没有听过 Git 和 Markdown，那么 gitbook 可能不适合你！ 本书也是使用 gitbook 生成，所以在看到这里的时候，你应该对 gitbook 的魔力有了初步印象！ Copyright © liujizhe.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-04-06 18:12:12 "},"GitBook/安装.html":{"url":"GitBook/安装.html","title":"安装","keywords":"","body":"安装 npm install gitbook-cli -g 其中gitbook-cli是gitbook的一个命令行工具, 通过它可以在电脑上安装和管理gitbook的多个版本. 需要注意的是：用户首先需要安装 nodejs，以便能够使用 npm 来安装 gitbook。 Copyright © liujizhe.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-04-07 10:37:57 "},"GitBook/使用.html":{"url":"GitBook/使用.html","title":"使用","keywords":"","body":"使用 快速开始 GitBook 1. 初始化 GitBook 1 # 创建 mygitbook 文件夹，并切换到这个文件夹下面 2 ~$ mkdir mygitbook && cd mygitbook 3 4 # 初始化 gitbook 工作目录，创建必要的文件 5 ~$ gitbook init 首先，初始化GitBook，创建两个 .md 格式的文件 README.md 和 SUMMARY.md README.md这个文件相当于一本Gitbook的简介。 SUMMARY.md这个文件是一本书的目录结构，使用Markdown语法。 例如： * [简介](README.md) * [第一章](chapter1/README.md) * [第一节](chapter1/section1.md) * [第二节](chapter1/section2.md) * [第二章](chapter2/README.md) * [第一节](chapter2/section1.md) * [第二节](chapter2/section2.md) * [结束](end/README.md) 其中，中括号内是章节名字，其为书右端可点击转跳的目录。后面小括号内为文件路径。 然后，定义好目录结构，再次通过 gitbook init 自动生成目录结构对应的文件夹和 Markdown 文件。 2. 启动服务 ~$ gitbook serve 3. 命令 列出gitbook所有的命令 gitbook help 输出gitbook-cli的帮助信息 gitbook --help 生成静态网页 gitbook build 生成静态网页并运行服务器 gitbook serve 更新到gitbook的最新版本 gitbook update Copyright © liujizhe.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-04-06 18:10:34 "},"Git/":{"url":"Git/","title":"简介","keywords":"","body":"简介 Git是目前世界上最先进的分布式版本控制系统（没有之一）。 Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。 Linus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？ 集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。 分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。 当然，Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。 Copyright © liujizhe.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-04-07 17:24:42 "},"Git/安装.html":{"url":"Git/安装.html","title":"安装","keywords":"","body":"安装 1. 初始化配置 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。 $ git config --global user.name \"Your Name\" $ git config --global user.email \"email@example.com\" 注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 让Git显示颜色，会让命令输出看起来更醒目 $ git config --global color.ui true 配置别名 $ git config --global alias.st status $ git config --global alias.co checkout $ git config --global alias.ci commit $ git config --global alias.br branch #命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区 $ git config --global alias.unstage 'reset HEAD' #配置一个git last，让其显示最后一次提交信息 $ git config --global alias.last 'log -1' $ git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)%Creset' --abbrev-commit\" 2. 配置文件 配置Git的时候，加上--global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。 配置文件放哪了？每个仓库的Git配置文件都放在.git/config文件中: $ cat .git/config #别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。 而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中： $ cat .gitconfig #配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。 3. 忽略特殊文件 有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次git status都会显示Untracked files ...，有强迫症的童鞋心里肯定不爽。这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览https://github.com/github/gitignoregit设置忽略文件和目录https://www.cnblogs.com/sagech/p/5709892.html Copyright © liujizhe.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-04-07 17:27:36 "},"Git/Git版本库.html":{"url":"Git/Git版本库.html","title":"Git版本库","keywords":"","body":"Git版本库 创建版本库 什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 #首先，选择一个合适的地方，创建一个空目录： $ mkdir learngit $ cd learngit $ pwd /Users/michael/learngit #第二步，通过git init命令把这个目录变成Git可以管理的仓库： $ git init Initialized empty Git repository in /Users/michael/learngit/.git/ 把文件添加到版本库 首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。 添加文件到Git仓库，分两步： 第一步，使用命令git add ，注意，可反复多次使用，添加多个文件； 第二步，使用命令git commit -m \"xxx\"，完成。-m后面输入的是本次提交的说明。 为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件。 工作区 就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区。 版本库（Repository） 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针HEAD。 Copyright © liujizhe.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-04-07 17:28:34 "},"Git/时光机穿梭.html":{"url":"Git/时光机穿梭.html","title":"时光机穿梭","keywords":"","body":"时光机穿梭 为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有修改提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交修改。你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 把文件修改添加到暂存区 $ git add 把所有的文件修改提交暂存区 $ git add . 如果你自动追踪文件，包括你已经手动删除的，状态为Deleted的文件 $ git add -u 把暂存区的所有修改提交到当前分支 git commit –m \"提交说明\" 查看仓库当前的状态 $ git status 查看修改内容 $ git diff 查看工作区和版本库里面最新版本的区别 $ git diff HEAD -- 每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。 查看提交历史 $ git log #如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数： $ git log --pretty=oneline #查看分支合并情况 $ git log --graph --pretty=oneline --abbrev-commit 查看命令历史 $ git reflog 版本回退 Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向当前版本改为指向另一个版本。首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 $ git reset --hard HEAD^ $ git reset --hard commit_id 丢弃工作区的修改 $ git checkout -- 命令git checkout -- 意思就是，把文件在工作区的修改全部撤销，这里有两种情况： 一种是自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 把暂存区的修改撤销掉（unstage），重新放回工作区 $ git reset HEAD git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 删除文件 #用命令git rm删掉，并且git commit： $ git rm $ git commit -m \"remove \" #如果删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本 $ git checkout -- test.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 Copyright © liujizhe.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-04-07 17:29:57 "},"Git/远程仓库.html":{"url":"Git/远程仓库.html","title":"远程仓库","keywords":"","body":"远程仓库 Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。 使用多个远程库时，我们要注意，git给远程库起的默认名称是origin，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。 添加远程库 现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 关联一个远程库 $ git remote add origin git@github.com:liujizhe/learngit.git 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 第一次推送master分支的所有内容 $ git push -u origin master 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的 master分支关联起来，在以后的推送或者拉取时就可以简化命令。 此后，每次本地提交后，只要有必要，就可以使用命令： $ git push origin master 把本地master分支的最新修改推送至GitHub。 从远程库克隆 当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，默认情况下，你只能看到本地的master分支，并且，远程仓库的默认名称是origin。 克隆一个仓库 $ git clone git@github.com:liujizhe/xxx.git 查看远程库的信息 $ git remote $ git remote -v #查看更详细的信息 删除已有的远程库 $ git remote rm 关联多个远程库 使用多个远程库时，我们要注意，git给远程库起的默认名称是origin，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。 关联GitHub的远程库： git remote add github git@github.com:liujizhe/ToolNote.git 关联码云的远程库: git remote add gitee git@gitee.com:liujizhe/ToolNote.git 如果要推送到GitHub，使用命令： git push github master 如果要推送到码云，使用命令： git push gitee master Copyright © liujizhe.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-04-07 17:39:18 "},"Git/分支管理.html":{"url":"Git/分支管理.html","title":"分支管理","keywords":"","body":"分支管理 分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN! 分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 创建与合并分支 每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。 HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点。 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上。Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！ 从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变。 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并。所以Git合并分支也很快！就改改指针，工作区内容也不变！ 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支。 创建并切换到某分支 $ git checkout -b 创建分支 $ git branch 切换到某分支 $ git checkout 查看分支 $ git branch 合并某分支到当前分支 $ git merge #Fast-forward(快进模式) 删除分支 $ git branch -d $ git branch -D #强行删除一个没有被合并过的分支 过程：创建并切换到dev，在dev分支上提交，切换回master分支，把dev分支的工作成果合并到master分支上，合并完成后，就可以放心地删除dev分支了。 解决冲突 当Git无法自动合并分支时，就必须首先解决冲突，解决冲突后，再提交，合并完成。用git log --graph --pretty=oneline --abbrev-commit命令可以看到分支合并情况。 分支管理策略 通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息,能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 加上--no-ff参数就可以用普通模式合并: $ git merge --no-ff -m \"xxx\" 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活;那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本;你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 Bug分支 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 $ git stash #把当前工作现场“储藏”起来，等以后恢复现场后继续工作 $ git stash list #列出所有stash 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；另一种方式是用git stash pop，恢复的同时把stash内容也删了： $ git stash apply stash@{0} $ git stash drop stash@{0} $ git stash pop 多人协作 当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，默认情况下，你只能看到本地的master分支，并且，远程仓库的默认名称是origin。 在本地创建和远程分支对应的分支 $ git checkout -b branch-name origin/branch-name #本地分支和远程分支的名称最好一致 推送分支 推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： $ git push origin branch-name 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 抓取分支 多人协作时，大家都会往master和dev分支上推送各自的修改。现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆： $ git clone git@github.com:liujizhe/learngit.git 当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看。 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支： $ git checkout -b dev origin/dev 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程。 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送 $ git push origin dev。 如果推送失败，是因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，先用$ git pull把最新的提交从origin/dev抓下来并合并到本地，如果合并有冲突，则手动解决冲突，并在本地提交，再推送。 如果git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接: $ git branch --set-upstream dev origin/dev 因此，多人协作的工作模式通常是这样： 首先，可以试图用$ git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用$ git pull抓取远程的新提交并合并到本地； 如果合并有冲突，则手动解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用$ git push origin branch-name推送！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令$ git branch --set-upstream branch-name origin/branch-name。 Copyright © liujizhe.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-04-07 17:31:14 "},"Git/标签管理.html":{"url":"Git/标签管理.html","title":"标签管理","keywords":"","body":"标签管理 发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。Git有commit，为什么还要引入tag？tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。 创建标签 在Git中打标签非常简单，首先，切换到需要打标签的分支上： $ git checkout 然后打一个新标签： $ git tag #默认标签是打在最新提交的commit上 #也可以指定一个commit id $ git tag commit id 创建带有说明的标签，用-a指定标签名，-m指定说明文字： $ git tag -a -m \"xxx\" commit id 查看所有标签 $ git tag 查看标签信息 $ git show 操作标签 推送一个本地标签 $ git push origin 推送全部未推送过的本地标签 $ git push origin --tags 删除一个本地标签 $ git tag -d 删除一个远程标签 #先从本地删除 $ git tag -d #然后，从远程删除 $ git push origin :refs/tags/ Copyright © liujizhe.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-04-07 17:32:06 "},"Git/使用GitHub.html":{"url":"Git/使用GitHub.html","title":"使用GitHub","keywords":"","body":"使用GitHub 在GitHub上，可以任意Fork开源仓库,点“Fork”就在自己的账号下克隆了一个开源仓库； 自己拥有Fork后的仓库的读写权限，一定要从自己的账号下将开源仓库克隆到本地电脑的仓库，这样你才能推送修改； 可以推送pull request给官方仓库来贡献代码。 Copyright © liujizhe.com 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-04-07 17:32:40 "}}